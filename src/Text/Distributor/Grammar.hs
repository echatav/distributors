{-# LANGUAGE
DerivingStrategies
, GADTs
, GeneralizedNewtypeDeriving
, LambdaCase
, MultiParamTypeClasses
, RankNTypes
#-}

module Text.Distributor.Grammar where

import Control.Distributor
import Control.Monad
import Control.Monad.Fix
import Data.Profunctor

{-| The type of `Token`s or "partial isomorphisms".-}
data Token s t a b where
  Token :: (a -> Maybe s) -> (t -> Maybe b) -> Token s t a b

{-| Lexical elements used in specifying the `Production`
`rule`s constituting a formal `Grammar`.-}
data Symbol r s t a b where
  {-| the elementary `Symbol`s of the language
  defined by a formal `Grammar`-}
  Terminal :: Token s t a b -> Symbol r s t a b
  {-| replaced by groups of `Terminal` `Symbol`s
  according to the `Production` `rule`s-}
  NonTerminal :: r a b -> Symbol r s t a b

{-| Specification of a `Production` `rule` as a
`Distributor` generated by `Symbol`s.-}
newtype Production r s t a b = Production
  { unProduction :: Dist (Symbol r s t) a b }
  deriving newtype (Profunctor, Bimodule, Distributor)

{- Specification of a formal `Grammar` as a
`MonadFix` generated by `Production` `rules`.-}
data Grammar r s a where
  RuleBind
    :: Production r s s a a
    -> (Production r s s a a -> Grammar r s b)
    -> Grammar r s b
  FixBind
    :: (a -> Grammar r s a)
    -> (a -> Grammar r s b)
    -> Grammar r s b
  Return :: a -> Grammar r s a

{- A `Production` `rule` is a rewrite rule specifying a `Symbol`
substitution that can be recursively performed to
generate new `Symbol` sequences. A finite set of `Production` `rule`s
is the main component in the specification of a formal `Grammar`.-}
rule :: Production r s s a a -> Grammar r s (Production r s s a a)
rule ps = RuleBind ps return

instance Functor (Grammar r s) where
  fmap f = \case
    RuleBind ps h -> RuleBind ps (fmap f . h)
    FixBind g h -> FixBind g (fmap f . h)
    Return x -> Return (f x)

instance Applicative (Grammar r s) where
  pure  = return
  (<*>) = ap

instance Monad (Grammar r s) where
  return = Return
  RuleBind ps f >>= k = RuleBind ps (f >=> k)
  FixBind f g >>= k = FixBind f (g >=> k)
  Return x >>= k = k x

instance MonadFix (Grammar r s) where
  mfix f = FixBind f return

runGrammar
  :: MonadFix m
  => (forall r s a. Production r s s a a -> m (Production r s s a a))
  -> Grammar r s a
  -> m a
runGrammar r = \case
  RuleBind p k -> do
    nt <- r p
    runGrammar r $ k nt
  Return a -> return a
  FixBind f k -> do
    a <- mfix $ runGrammar r <$> f
    runGrammar r $ k a

class Grammatical s a where
  grammar :: forall r. Grammar r s (Production r s s a a)
